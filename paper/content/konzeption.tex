\chapter{Konzeption}\label{chapter:concept}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\imiscomment{Grobkonzeption der Arbeit}

%\imiscomment{Keine Codedarstellung, allenfalls Pseudocode}

%\imiscomment{Struktur dieses Kapitel kann je nach Problemstellung unterschiedlich gestaltet werden}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Systemarchitektur}\label{sec:architecture}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In Abbildung \ref{fig:architecture} wird die Modularität der Architektur des Simulators deutlich. Die Komponenten in den weißen Kästen stellen Module dar, die durch den Austausch weniger Codezeilen ausgewechselt werden können. Diese Komponenten sind zum Teil simulationsspezifisch. Zum Beispiel sind Sensoren, Aktuatoren und Aktionen vom Simulationsumfeld abhängig. Darüber hinaus bestehen auch die Abhängigkeiten Sensoren $\leftrightarrow$ Aktionen und Aktuatoren $\leftrightarrow$ Aktionen, da Sensoren auf bestimmte Aktionen reagieren und Aktuatoren bestimmte Aktionen auslösen können.

Die Pfeile in der Abbildung geben den Hauptinformationsfluss zwischen den Komponenten an.

% this is an example for using TikZ:
\begin{figure}[htb]
  \begin{center}
	\begin{tikzpicture}[minimum width=3.3cm,minimum height=0.8cm]
	\tikzset{
    myarrow/.style={->, >=latex', shorten >=1pt, thick},
	highlight/.style={rectangle, draw, fill=black!10},
	normal/.style={rectangle,rounded corners, draw}
} 
	\node[highlight] (engine) at (2,-2) [draw] {\emph{Simulationsengine}};
	\node[normal] (generator) [above left=of engine]{Generatoren};
	\node[normal] (kommunikation) [right=of engine]{Kommunikation};
	\node[normal] (benutzung) [below left=of engine]{Benutzung};
	\node[normal] (sensoren) [above right=of engine]{Sensoren};
	\node[normal] (aktuatoren) [below right=of engine]{Aktuatoren};
	\node[normal] (aktionen) [above=of engine]{Aktionen};
	\node[normal] (aktionsverwaltung) [below=of engine]{Aktionsverwaltung};
	
	\draw[->, thick, >=latex', shorten >=1pt]
	(generator) edge (engine)
	(aktuatoren) edge (engine)
	(engine) edge (sensoren)
	(kommunikation) edge (aktuatoren)
	(sensoren) edge (kommunikation)
	;
	\draw[<->, thick, >=latex', shorten >=1pt]
	(engine) edge (kommunikation)
	(engine) edge (aktionen)
	(engine) edge (benutzung)
	(engine) edge (aktionsverwaltung)
	;
    \end{tikzpicture}
  \end{center}
  \caption{{Unterteilung der Simulatorarchitektur in Module}}
  \label{fig:architecture}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Simulationsengine}\label{subsec:concept_engine}

Der Kern des Simulationsframeworks ist die Simulationsengine, die im wesentlichen aus den Klasse \texttt{SimulationEngine} und \texttt{SimulationClock} besteht. Sowohl die Clock als auch die Engine sind als Singleton realisiert und können deshalb aus jeder Klasse angesprochen werden.

Die SimulationClock repräsentiert die Zeit in der Simulation. Die Geschwindigkeit der Uhr und somit die Geschwindigkeit der Simulation kann skaliert werden. Der Skalierungsfaktor in der Uhr gibt dabei an, wie viele Millisekunden in Echtzeit einer simulierten Sekunde entsprechen. Somit resultiert ein niedriger Wert in einer höheren Geschwindigkeit.

Klassen können das \texttt{ISimulationClockListener}-Interface implementieren und sich bei der Clock als Listener registrieren, um über Events wie das Ticken der Uhr, das Pausieren, Starten und Stoppen der Simulation informiert zu werden.

Die Engine hält die Welt (\texttt{World}) bereit, welche die Konfiguration und das Verhalten der Simulation beschreibt. Darüber hinaus hält die Engine Referenzen auf den Kommunikationshandler, der in unserer Implementierung für die Kommunikation mit dem MACK Server zuständig ist.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\imiscomment{Grobkonzeption eines einzelnen Moduls}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Generatoren}\label{subsec:concept_generators}
Generatoren erzeugen \texttt{World}-Objekte, die von der Simulationsengine simuliert werden können.

Ein Generator muss sich darum kümmern, Räume, Sensoren, Aktuatoren, Agenten und Aktionen zur erzeugen und geeignet zu verknüpfen. In unserer Implementierung gibt es einen Generator, der eine Welt erzeugt, in dem fest einprogrammiert Java-Objekte erzeugt werden.

Eine weitere Möglichkeit für einen Generator wäre ein XML Handler, der Java-Objekte aus einer XML-Beschreibung generiert.

Generatoren können in der Main-Klasse des Simulators ausgetauscht werden. Die einzigen Vorraussetzungen, die ein Generator erfüllen muss, sind, dass er das \texttt{IWorldGenerator}-Interface implementiert und eine vollständige Welt erzeugt.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Benutzungsschnittstellen}\label{subsec:concept_interfaces}
Benutzungsschnittstellen können bereit gestellt werden, indem eine Implementierung des Interfaces \texttt{IMainView} in der Main-Klasse des Simulators an den \texttt{MainController} übergeben wird. Die Benutzungsschnittstellen können sowohl passiv als auch interaktiv gestaltet werden. Hierfür können sich Objekte des Interfaces als Listener bei den Objekten des Modells registrieren und auf die \texttt{SimulationClock} und die Engine zugreifen, da beide Komponenten als Singleton realisiert sind.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Aktionen}\label{subsec:concept_actions}
Aktionen können allgemein durch folgende Parameter spezifiziert werden:
\begin{description}
	\item[priority] Die Priorität einer Aktion als Integer zwischen \texttt{0} und \texttt{10}.
	\item[duration] Die Dauer in Sekunden oder \texttt{-1}, falls keine Dauer angegeben wird (z.B. bei \texttt{Move}-Aktionen, die dann fertig sind, wenn das Ziel erreicht wurde).
	\item[earliestStartTime] ein Zeitpunkt (\texttt{SimulationTime}), ab dem die Aktion gestartet werden darf oder \texttt{null}, falls die Aktion zu einem beliebigen Zeitpunkt gestartet werden kann.
	\item[deadline] ein Zeitpunkt, zu dem die Aktion erledigt sein muss oder \texttt{null}, falls keine Headline angegeben wurde.
	\item[state] der aktuelle Status der Aktion, z.B. \texttt{SCHEDULED}, wenn die Aktion einem Agenten hinzugefügt wurde, dieser sie aber noch nicht ausgeführt hat, \texttt{ONGOING}, wenn die Aktion gerade durchgeführt wird oder \texttt{COMPLETED}, wenn die Aktion erfolgreich durchgeführt wurde.
\end{description}
Es gibt \texttt{AtomicAction}s und \texttt{ComplexAction}s, welche aus einer Liste von atomaren Aktionen bestehen können. Mit diesem Konstrukt lassen sich unter anderem Aktionen wie das aufsuchen und reden mit einer anderen Person (\texttt{Agent}) beschreiben.

Um eine neue Aktion zur Verfügung zu stellen, muss eine neue Klasse implementiert werden, die von einer der abstrakten Klassen \texttt{AtomicAction} oder \texttt{ComplexAction} erbt. Die eigentliche Aktion muss in der \texttt{internalPerform(AbstractComponent performer)}-Methode beschrieben werden. Sollten vor der ersten Ausführung der Aktion Konfigurationsschritte notwendig sein, können diese in der Methode \texttt{preActionTask(AbstractComponent performer)} beschrieben werden. Analog dazu gibt es auch eine Methode \texttt{postActionTask(AbstractComponent performer)}, die vom Framework aufgerufen wird, nachdem der Job erledigt wurde.

Wenn eine Dauer angegeben wurde, kümmert sich dass Simulationsframework um das Dekrementieren der Zeit, in diesem Fall muss die \texttt{internalPerform(AbstractComponent performer)}-Methode immer \texttt{false} zurückgeben. Sobald diese Methode \texttt{true} zurückgibt, gilt die Aktion als erledigt und es wird im Falle einer komplexen Aktion mit der nächsten atomaren Aktion fortgefahren.

Aktionen müssen vom Generator erzeugt werden und einem oder mehreren Agenten hinzugefügt werden.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Aktionsverwaltung}\label{subsec:concept_actionhandling}
Zur Aktionsverwaltung hat jeder Agent einen \texttt{IActionScheduler}, der im Konstruktor ausgetauscht werden kann. Die Aufgabe des Schedulers ist es, die Aktions-Sammlungen bereit zu halten. Das Konzept sieht vor, dass es für jeden Agenten drei Listen von Aktionen gibt:
\begin{description}
	\item[todoList] Diese Liste beinhaltet Aufgaben, die in jedem Fall während der Simulation entsprechend ihrer oben beschriebenen Parameter ausgeführt werden sollen.
	\item[actionPool] Diese Menge enthält Aufgaben, die optional ausgeführt werden können, wenn der Agent gerade keine anderen Aufgaben zu erledigen hat.
	\item[interruptActionList] In diese Liste werden während der Simulation Aktionen eingeordnet, die in jedem Fall unmittelbar als nächste Aktionen ausgeführt werden müssen. Sinnvoll ist dies insbesondere dann, wenn ein Agent darauf angewiesen ist, dass ein anderer Agent mit ihm interagiert. Dem zweiten Agenten kann dann eine Aktion auf die Interuppt-Liste gesetzt werden, damit er unmittelbar bei der nächsten Gelegenheit mit dem ersten Agenten interagiert und keine anderen Aktionen vorzieht.
\end{description}

Die Kernfunktionalität eines Action-Schedulers ist es, mit geeigneten Algorithmen zu jedem Zeitpunkt eine Aktion auszuwählen. Hierzu ruft der Agent die \texttt{getNextAction()}-Methode auf, worauf hin der Scheduler eine Aktion auswählt und diese von der Liste löscht.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Kommunikationshandlern}\label{subsec:concept_communication}
Ein Kommunikationshandler muss das \texttt{ICommunicationHandler}-Interface implementieren. Kommunikationshandler sind für die Verwaltung der Kommunikation mit einem beliebigem Gegenpart außerhalb des Simulators zuständig. Ein konkretes Beispiel ist ein Netzwerkhandler, der die Kommunikation über eine Netzwerkschnittstelle verwalten kann. In der aktuellen Implementierung ist der \texttt{MACKNetworkHandler} ein Kommunikationshandler der den Informationsaustausch mit dem MACK Server realisiert.

Innerhalb der Simulation interagiert der Kommunikationshandler mit Sensoren und Aktuatoren, die beide das Interface \texttt{ICommunicationComponent} implementieren.. Die Komponenten registrieren sich in der Initialisierungsphase des Simulators beim Handler, indem die Methode \texttt{re\-gister (ICommunication\-Component comp)} aufgerufen wird.

Während der Simulation können die Komponenten die \texttt{send(ICommunication\-Component\\
sender, Object message)}-Methode aufrufen, um eine Nachricht an den Handler zu senden. Umgekehrt kann der Handler bei den Komponenten die Methode \texttt{receive(Object message)} aufrufen, um eine neu eingetroffene Nachricht zu übermitteln.

Zu beachten ist, dass die Nachrichten zunächst vom Typ \texttt{Object} sind, um einen hohen Abstraktionsgrad zu gewährleisten. Von welchem Typ die Nachrichten wirklich sind, muss in Sensoren, Aktuatoren und dem Handler während der Implementierung entschieden werden.

In der spezifischen Simulation und dem \texttt{MACKCommunicationHandler} sind Nachrichten immer vom Typ \texttt{String}, wobei die Nachrichten im XML-Format sind, welches auch das MACK-Framework verwendet. Ausgehende Nachrichten werden von den Sensoren und Aktuatoren unter Verwendung der \texttt{MACKProtocolFactory} erzeugt.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Sensoren und Aktuatoren}\label{subsec:concept_actuators_sensors}
Da Sensoren und Aktuatoren viele Gemeinsamkeiten aufweisen, müssen alle konkreten Sensoren und Aktuatoren von der abstrakten Klasse \texttt{AbstractInteractionComponent} erben, die auch das \texttt{ICommunication\-Component}-Interface implementiert.

Beide Komponenten haben einen Bereich, in dem sie auf Aktivitäten reagieren oder bei den Agenten Aktivitäten auslösen können. Der Bereich kann als Ausrichtung (Blickrichtung), Öffnungswinkel und Radius definiert werden, indem der entsprechende Konstruktor verwendet wird. Werden diese Parameter nicht angegeben, wird der komplette Raum, in dem sich eine Komponente befindet überwacht. Mit der Methode \texttt{setShapeRepresentation(Shape shape)} kann darüber hinaus eine beliebige Shape als Überwachungsbereich festgelegt werden.

Die Komponenten können die Methoden \texttt{boolean checkInterest\-(AbstractAction\\
action, Agent agent)} und \texttt{boolean checkInterest(Agent agent)} implementieren, um anzugeben ob die jeweilige Komponente an einem Agenten und/oder einer Aktion eines Agentens interessiert ist. Standardmäßig geben beide Methoden \texttt{false} zurück. In der Initialisierungsphase werden alle interessierten Komponenten den Agenten als \texttt{IExtendedAgentListener} hinzugefügt und werden damit automatisch informiert, wenn ein Agent, an dem die Komponente interessiert ist, eine Aktion durchführt.

 Bereits in der Elternklasse \texttt{AbstractInteractionComponent} aller Sensoren und Aktuatoren wird darauf geachtet, dass die eigentliche Methode zum Reagieren auf Agenten und Aktionen (\texttt{boolean handleInternal(AbstractAction action, Agent agent)}) nur dann aufgerufen wird, wenn sich der Agent im Überwachungsbereich der Komponente befindet.

Der einzige Unterschied zwischen Sensoren und Aktuatoren ist, dass der Rückgabewert der \texttt{handle\-Internal}-Methode von Sensoren ignoriert wird. Bei Aktuatoren oder Mischformen von Sensoren und Aktuatoren ist der Rückgabewert als Erlaubnis für eine Aktion zu verstehen. Wenn also ein Agent eine Aktion durchführt und die Methode \texttt{false} zurückgibt, bricht der Agent die Aktion ab.

Der Typ der Komponenten wird angeben, indem die \texttt{type}-Variable gesetzt wird. Sie kann die Werte \texttt{SENSOR}, \texttt{ACTUATOR} und \texttt{MIXED} annehmen. Der Typ \texttt{MIXED} kann unter anderem für Wearables wie z.B. Smartphones sinnvoll sein.

Wearables können mit dem Konzept realisiert werden, indem mit der Methode \texttt{setAgent(Agent agent)} ein Agent gesetzt wird, der der Hauptinhaber der Komponente ist. Darüber hinaus muss mit der Methode \texttt{setWearable(boolean wearable)} festgelegt werden, dass die Komponente ein Wearable ist. Dann wird jedes mal, wenn der Agent seine Position ändert, die Position der Komponente ebenfalls neu gesetzt.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Realisierung}\label{chapter:realization}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\imiscomment{Beschreibung der hard- und software-technischen Realisierung}

\imiscomment{Struktur dieses Kapitel kann je nach Problemstellung unterschiedlich gestaltet werden}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Realisierung der Einzelmodule}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Simulationsengine \& Simulationclock}\label{subsec:real_engine}
\subsubsection{SimulationEngine}
Die \codeclass{SimulationEngine} ist als Singleton realisiert. Dies hat den Vorteil, dass es zur Laufzeit nur eine Instanz von ihr geben kann, die in allen Klassen verfügbar ist. Diese Instanz hält die \codeclass{World}, den \codeclass{CommunicationHandler} bereit. Beide Objekte können vor dem Start der Simulation, d.h. vor dem Start der \codeclass{SimulationClock} mit den jeweiligen Setter-Methoden gesetzt werden. Der Aufruf dieser Methoden nach dem Start der Simulation erzeugt einen \codeclass{IllegalAccessException}.

Während der Simulation können die Welt und der Kommunikationshandler über die Getter-Methoden abgerufen werden. Auf diesem Weg können unter anderem Sensoren und Aktuatoren den Kommunikationshandler erreichen. Auch die graphische Oberfläche holt sich die zu zeichnenden Objekte über die Simulationsengine.

\subsubsection{SimulationClock}
Die \codeclass{SimulationClock} ist das Herzstück der Simulation. Sie stößt sämtliche Aktionen der Komponenten des Modells an. Die Clock ist wie die Engine ebenfalls mit dem Singleton-Designpatter realisiert. So ist sicher gestellt, dass es nur eine Uhr geben kann, die aus allen Klassen erreichbar ist.

Die \codeclass{SimulationClock} verwendet das Listener-Konzept, um Komponenten, die an der Simulationszeit interessiert sind regelmäßig über Änderungen zu informieren. Komponenten die sich als Listener bei der Uhr registrieren möchten müssen dazu das \codeclass{ISimulationClockListener}-Interface implementieren und können dann mit \begin{lstlisting}
SimulationClock.getInstance()
.addListener(ISimulationClockListener);
\end{lstlisting}
hinzugefügt und analog mit
\begin{lstlisting}
SimulationClock.getInstance()
.removeListener(ISimulationClockListener);
\end{lstlisting}
wieder entfernt werden.

Über das Listener-Konzept werden in jeder simulierten Sekunden Aktionen bei den Listenern angestoßen. Standardmäßig ist es nicht möglich, eine Java-Collection während des Durchlaufens dieser zu verändern. Somit wäre es unmöglich, dass sich eine Komponente als Listener abmelden kann. Die \codeclass{SimulationClock} speichert jedoch alle Hinzufüge- und Entfernanfragen an die Listener-Collection zwischen und führt diese vor dem nächsten Durchlauf aus.

Die Uhr basiert auf einem Timer-Thread, der alle $x$ Millisekunden auslöst. Wenn die Uhrzeit skaliert wird, wird mit dem nächsten Tick ein neuer Timer eingerichtet. Das pausieren der Simulation stoppt nicht den Timer-Thread sondern verhindert lediglich, dass dieser die \codeclass{SimulationTime} inkrementiert.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Generatoren}\label{subsec:real_generator}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Benutzungsschnittstellen}\label{subsec:real_interfaces}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Aktionen}\label{subsec:real_actions}
In unserer Implementierung sind verschiedenen Aktionen enthalten. In der Package-Struktur haben wir diese wie folgt aufgeteilt:

In \codeinline{.simulation.model.actions} befinden sich Aktionen, die allgemein im Simulator durchgeführt werden können. Diese sind unabhängig vom MACK Framework, Sensoren und Aktuatoren.

Im Package \codeinline{.simulation.model.mackActions} befinden sich Aktionen, die bestimmte Sensoren und Aktuatoren benötigen und somit abhängig von der jeweiligen Simulation sind.

\subsubsection{Allgemeine Aktionen}
Zu den wichtigsten allgemeinen Aktionen in unserer Implementierung zählen unter anderem:
\begin{description}
	\item[Move] Die \codeclass{Move}-Aktion dient dazu, die Position eines Agentens zu Ändern. Hierbei wird in der Initialisierung der Aktion nur das Ziel angegeben. Zum Zeitpunkt der Ausführung der Aktion wird automatisch der Weg zum Ziel berechnet und pro Iteration die Position um eine bestimmte Anzahl von Wegpunkten verändert. Dieser Aktion kann keine Dauer übergeben werden, da sie automatisch terminiert, wenn das Ziel erreicht wurde. Gibt es keinen Weg zum Ziel. Bricht die Aktion automatisch ab.
	\item[Follow] Mit der \codeclass{Follow}-Aktion kann ein Agent einer  \texttt{AbstractComponent}  folgen. Somit ist es möglich, dass ein Agent einem anderen während eines Gespräches folgt. Die Aktion hat keine spezifische Dauer, sondern wird erst dann beendet, wenn \texttt{Follow.complete()} aufgerufen wird.
	\item[SpeakTo] Mit dieser Aktion kann ein Agent mit einem anderen Sprechen. Hierbei wird zunächst überprüft, ob beide Agenten im selben Raum sind. Außerdem wird überprüft, ob die Aktion des anderen Agentens eine Unterbrechung zulässt.
	
	Wenn der Agent unterbrechbar ist, wird ihm eine Aktion vom Typ \codeclass{Follow} in die \codeinline{interrupt\-List} gelegt, so dass der Agent für die Dauer des Gespräches dem Sprecher folgt und ebenfalls mit dem Gespräch beschäftigt ist. Dies verhindert, dass der andere Agent im Gespräch wegläuft. In der Methode \codeclass{SpeakTo}\codemethod{.postActionTask(AbstractComponent)} wird \codeclass{Follow}\codemethod{.complete()} aufgerufen und somit der Gesprächspartner wieder freigegeben.
	\item[GoAndSpeakTo] Diese \codeclass{ComplexAction} sorgt dafür, dass der ausführende Agent zunächst die Standard-Position des Gesprächspartners aufsucht, welche in der Regel sein Büro ist, und dort versucht, mit ihm zu reden. 
	
	In der aktuellen Implementierung bricht der Agent diese Aktion ab, wenn der Partner sich nicht in seinem Büro befindet. Diese Aktion kann aber erweitert werden, wenn es z.B. Aktuatoren wie das \codeclass{DoorPlate} gibt, welches Auskunft über die wirkliche Position des Anderen gibt.
\end{description}
\subsubsection{Simulationsspezifische Aktionen}
Die simulationspezifischen Aktionen hängen von Sensoren und Aktuatoren einer Simulationsimplementierung ab. In der aktuellen Implementierung gibt es unter anderem folgende Aktionen:
\begin{description}
	\item[WorkOnDesktop] Mit dieser Aktion kann man einen Agenten für eine bestimmte Zeit arbeiten lassen. Hierfür erzeugt man eine neue Instanz dieser Klasse und gibt im Konstruktor den Arbeitsplatz, die Programmklasse, die Frequenz und die Dauer an.
	
	Die Programmklasse ist dabei äquivalent zu den Klassen, mit denen auch das MACK Framework umgehen kann. Die Frequenz ändert sich während der Ausführung um einen normalen Arbeitsfluss zu simulieren.
	\item[TurnCube] Mit der \codeclass{TurnCube}-Aktion kann ein \codeclass{Cube} (Cubus) auf einen bestimmten Status gedreht werden.
	\item[PutKeyInDropZone] Diese Aktion fügt eine Referenz auf den Agenten in eine Liste einer Dropzone. Vorher wird überprüft, ob der Agent bereits einer anderen \codeclass{DropZone} hinzugefügt wurde, um zu vermeiden, dass der Agent seinen \glqq Schlüssel\grqq\ in mehrere Dropzones legen kann.
	\item[RemoveKeyFromDropZone] Analog zur \codeclass{PutKeyInDropZone}-Aktion kann mit dieser Aktion eine Referenz auf einen Agenten aus einer \codeclass{DropZone} entfernt werden.
\end{description}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Aktionsverwaltung}\label{subsec:real_actionhandling}
In unserer Implementierung nutzt der ActionScheduler im Wesentlichen den Scheduling-Algorithmus \emph{Earliest Deadline First}. Darüber hinaus nutzt der Scheduler weitere Möglichkeiten um auch Parameter außer der Deadline zu berücksichtigen, da nicht jede Aufgabe eine Deadline haben muss. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Kommunikationshandler}\label{subsec:real_communication}
Die abstrahierte Beschreibung der Schnittstellen eines Kommunikationshandlers befindet sich im Paket \codeinline{de.uniluebeck.imis.casi.communication}. 

Eine Implementierung für die Zusammenarbeit mit dem MACK Framework befindet sich in \codeinline{de.uni\-luebeck.imis.casi\-.com\-munication.mack}. \emph{Bei Änderungen am MACK-Protokoll sind im Wesentlichen die Methoden in diesem Paket anzupassen.}
Kommunikationshandler können die externe Kommunikation des Simulators ermöglichen. Dies bedeutet, dass sie sehr flexibel sein müssen, um jede erdenkliche Art von Kommunikation zu ermöglichen. Aus diesem Grund sind Kommunikationshandler als Implementierung des \codeinline{ICommunication\-Handler}-Interface realisiert und müssen in der Main-Klasse \codeclass{CASi} an den \codeclass{MainController} übergeben werden. Es ist nur ein Kommunikationshandler zur Zeit vorgesehen. Benötigt man mehrere Handler, sind Subhandler denkbar, denen die Nachrichten weiter gegeben werden.

In der Umsetzung des Simulators zum Testen des MACK Frameworks wurde der Kommunikationshandler \codeclass{MACKNetworkHandler} wie folgt realisiert:

Der Handler bekommt zu Beginn eine Konfigurationsdatei in XML Format übergeben, die in diesem Fall Java Beans XML enthält, mit dem die allgemeine Konfiguration der Netzwerkschnittstelle und die zur Verfügung stehenden \codeinline{XmppIdentifier} aufgelistet sind. Jeder \codeinline{XmppIdentifier} setzt sich aus drei \codeclass{String}-Werten zusammen und repräsentiert eine Zeile aus der Tabelle \texttt{mate\_user\-devices} des Servers:\begin{description}
	\item[componentOwner] Der eindeutige Name des Agents, dem die Komponente zugeordnet ist. Dieser \codeclass{String} muss identisch mit dem Feld \texttt{username} in der Tabelle \texttt{mate\_userdevices} sein.
	\item[componentType] Die Art der Komponente. Dieser \codeclass{String} muss identisch mit dem Feld \texttt{channel} in der Tabell sein.
	\item[id] Der XMPP Benutzername der Komponente ohne den Host (\texttt{@server.de}).
\end{description}

Die Netzwerkconfigurationsdatei enthält für jeden \codeinline{XmppIdentifier} einen Eintrag der Form
\begin{lstlisting}[language=XML]
<void method="add">
	<object class="de.uniluebeck.imis.casi.communication
	               .mack.XmppIdentifier">
		<void property="componentOwner">
			<string>casi_hermann_matsumbishi</string>
		</void>
		<void property="componentType">
			<string>doorlight</string>
		</void>
		<void property="id">
			<string>CASi_MATe_doorlight_0</string>
		</void>
	</object>
</void>
\end{lstlisting}
 im Bereich der \codeclass{ArrayList} \texttt{useableJabberIdentifiers}. In der Initialisierungsphase des Simulators wird jeder Komponente, die sich mit \begin{lstlisting}
public void register(ICommunicationComponent comp);
\end{lstlisting}
am \codeclass{MACKNetworkHandler} anmeldet, eine Jabber-ID aus dieser Liste zugewiesen, sofern noch eine zum jeweiligen Typ passende verfügbar ist. Andernfalls wird eine Warnung ausgegeben und die Komponente nicht angemeldet.
In der Registrierungsphase überprüft der Handler, ob der jeweilige Jabber-Identifier bereits am XMPP-Server registriert ist. Ist dies nicht der Fall, versucht der Simulator automatisch, den Identifier zu registrieren. Wenn mehrere Adressen noch nicht registriert wurden, kann es abhängig vom in der Konfigurationsdatei angegebenen \texttt{REGISTRATION\_DELAY} zum längeren Wartezeiten kommen, bevor der Simulator mit der Simulation beginnt. Wenn jedoch alle Komponenten bereits registriert sind, kann die Simulation ohne Wartezeit starten.

Der \codeclass{MACKNetworkHandler} erzeugt nach erfolgreichem Zuordnen der Identifier und dem Login am Jabber-Server für jede Komponente einen Chat mit dem MACK-Server. Über diesen Chat werden Pull- und Push-Requests gesendet und Rückmeldungen empfangen und an die betroffene Komponente weitergeleitet.

Sowohl die \codemethod{send}-Methode im \codeinline{ICommunicationHandler}-Interface, als auch die \codemethod{receive}-Methode im \codeinline{ICommunicationComponent}-Interface sehen vor, dass die Nachrichten vom Typ \codeclass{Object} sind. Hierdurch ist ein hoher Abstraktionsgrad und somit eine hohe Flexibilität gegeben. Für die richtige Interpretation der Nachrichten ist somit der Entwickler des Handlers und der Sensoren und Aktuatoren verantwortlich.

In der MATe Implementierung sind die Nachrichten immer vom Typ \codeclass{String}, da sie die den Body der Chat-Nachrichten, also die eigentliche Nachricht im Format des MACK-Protokolls enthalten.

Zum Erzeugen der Nachrichten in den Aktuatoren und Sensoren kann die \codeclass{MACKProtocollFactory} verwendet werden. Hierfür steht für Push- und Pull-Nachrichten je eine Methode zur Verfügung. Nachrichten, die vom MACK-Server empfangen werden, können mit der \codemethod{parseMessage} in ein \codeclass{MACKInformation}-Objekt zerlegt werden, das die Antwort in einer leicht zugänglichen Form bereit hält.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Sensoren und Aktuatoren}\label{subsec:real_sensors}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\imiscomment{UML-Diagramme}

\imiscomment{Schnittstellen}

\imiscomment{Datenmodelle}

%You might want to include listings:
%
% this example listing is inside a float environment, but
% the option [H] makes it stay put:
%\begin{illfloat}[H]
%  \begin{lstlisting}
%for i:=maxint to 0 do
%begin
%{ do nothing }
%end;
%Write('Case insensitive ');
%Write('Case insensitive ');
%Write('Case insensitive ');
%Write('Case insensitive ');
%Write('Case insensitive ');
%Write('Case insensitive ');
%WritE('Pascal keywords.');
%  \end{lstlisting}%
%  \illcaption{Ein Quelltext -- wirklich hier.}
%\end{illfloat}
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\subsection{Realisierung von Modul 2}\label{subsec:real_module_2}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% this example listing can float - we can not use the
% listings.sty option[flat] since that would disconnect
% the listing from the illcaption
%\begin{illfloat}
%  \begin{lstlisting}
%for i:=maxint to 0 do
%begin
%{ do nothing }
%end;
%Write('Case insensitive ');
%Write('Case insensitive ');
%Write('Case insensitive ');
%Write('Case insensitive ');
%Write('Case insensitive ');
%Write('Case insensitive ');
%Write('Case insensitive ');
%Write('Case insensitive ');
%Write('Case insensitive ');
%WritE('Pascal keywords.');
%  \end{lstlisting}%
%  \illcaption{Test einer sehr langen Beschreibung um den Flow zu testen. Test einer sehr langen Beschreibung um den Flow zu testen. Test einer sehr langen Beschreibung um den Flow zu testen. Test einer sehr langen Beschreibung um den Flow zu testen. Test einer sehr langen Beschreibung um den Flow zu testen. Test einer sehr langen Beschreibung um den Flow zu testen.}[Optionaler Kurzeintrag]
%\end{illfloat}
%
%You do not want to show full program listings, but short snipplets to show how a protocol looks like.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%